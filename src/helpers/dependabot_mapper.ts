import ora, { oraPromise } from "ora";
import {
  GeneratedTemplate,
  GeneratedUpdate,
  Template,
  Update,
  template,
} from "../models/template";
import { startFileSearch } from "./path_gatherer";
import { DebugLogger } from "./debug_logger";
import { Ecosystem, Schedule, Version } from "../models/enums";
import { env } from "process";
import fs from 'fs';


export class DependabotMapper {
  private version: Version = Version.v2;
  private base: string = '';
  private ecosystemsCount: number = 0;
  private template: Template;

  constructor(template: Template) {
    if (template) {
      if (!this.isTemplateValid(template)) {
        throw new Error("Template is not valid");
      }
      this.template = template;
      this.version = template.version;
    } else {
      throw new Error("Template is null");
    }

    this.base += `# Generated by Dependabot Generator ver. ${env.VERSION}\n`
    this.base += `version: ${this.version}\n`;
    this.base += `updates:\n`;
  }

  addEcosystem() {
    this.ecosystemsCount++;
  }

  isTemplateValid(template: Template): boolean {
    // checks version
    if (!Object.values(Version).find((x) => x === template.version))
      return false;
    // checks each ecosystem
    template.updates.forEach((update) => {
      if (!Object.values(Ecosystem).find((x) => x === update.ecosystem))
        return false;
    });
    // checks each schedule
    template.updates.forEach((update) => {
      if (!Object.values(Schedule).find((x) => x === update.schedule))
        return false;
    });
    return true;
  }

  async mapAllUpdates(): Promise<GeneratedTemplate> {
    let result: GeneratedTemplate = new GeneratedTemplate();
    result.version = this.version;
    for (const update of this.template.updates) {
      // create section
      const toPush = {
        ecosystem: Ecosystem[update.ecosystem],
        elements: await oraPromise(
          this.generateUpdatesFromUpdate(update),
          `Generating updates for ${update.ecosystem}`
        ),
      };

      result.updates.push(toPush);

      DebugLogger.log(toPush, "DEBUG - toPush in mapAllUpdates()");
    }
    return result;
  }

  // todo: check duplicates in Updates[]
  // private checkDuplicatesInUpdates(): boolean {
  //   const updates = this.template.updates;
  //   return false;
  // }

  private async generateUpdatesFromUpdate(
    update: Update
  ): Promise<GeneratedUpdate[]> {
    let result: GeneratedUpdate[] = [];
    const paths = await oraPromise(
      startFileSearch(update.pathRoot, Ecosystem[update.ecosystem])
    );
    DebugLogger.logPaths(paths);

    paths.forEach((el) => {
      result.push({
        ecosystem: Ecosystem[update.ecosystem],
        path: el.path,
        schedule: Schedule[update.schedule],
      });
    });

    return result;
  }

  async map(): Promise<boolean> {
    let mappedUpdates = await this.mapAllUpdates();
    DebugLogger.log(mappedUpdates, "DEBUG - mappedUpdates in map()");
    // remove duplicates
    // todo: remove duplicates

    // build dependabot config
    const dependabotConfig = this.buildDependabotConfig(mappedUpdates);
    // try to write to file
    this.writeDependabotConfig(dependabotConfig);

    return true;
  }

  private writeDependabotConfig(dependabotConfig: string): boolean {
    const path = "./.github/dependabot.yml";
    fs.writeFileSync(path, dependabotConfig);
    return true;
  }

  private buildDependabotConfig(generatedTemplate: GeneratedTemplate): string {
    let resultYaml = "";
    resultYaml = this.base;

    generatedTemplate.updates.forEach((update) => {
      resultYaml += `# ${update.ecosystem}\n`;

      update.elements.forEach((element) => {
        resultYaml += `- package-ecosystem: "${element.ecosystem}"\n`;
        resultYaml += `  directory: "${element.path}"\n`;
        resultYaml += `  schedule:\n`;
        resultYaml += `    interval: "${element.schedule}"\n`;
      });
    });

    DebugLogger.log(resultYaml, "DEBUG - resultYaml in buildDependabotConfig()");
    return resultYaml;
  }
}
